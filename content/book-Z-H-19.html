<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">

<html>
<!-- Generated from TeX source by tex2page, v 4o, 
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page -->

<head>
  <meta name="generator" content="HTML Tidy for Linux (vers 7 December 2008), see www.w3.org" />

  <title>Structure and Interpretation of Computer Programs</title>
  <link href="book-Z-C.css" title="default" rel="stylesheet" type="text/css" />
  <meta name="robots" content="noindex,follow" />
</head>

<body>
  <mbp:pagebreak />

  <p><a name="%_chap_3"></a></p>

  <div class="chapterheading">
    <h3 class="chapter"><a href="book-Z-H-4.html#%_toc_%_chap_3">Chapter 3</a></h3>
    <h1>Modularity, Objects, and State</h1>
  </div>

  <div align="left">
    <table width="60%">
      <tr>
        <td>
          <div><span class="epigraph">M<img src="ch3-Z-G-1.gif" border="0" /></span></div>

          <div><span class="epigraph">(Even while it changes, it stands still.)</span></div>

          <div><span class="epigraph attrib"><a name="%_idx_2820"></a>Heraclitus</span></div>

          <div><span class="epigraph">Plus &ccedil;a change, plus c'est la m&ecirc;me chose.</span></div>

          <div><span class="epigraph attrib"><a name="%_idx_2822"></a>Alphonse Karr</span></div>
        </td>
      </tr>
    </table>
  </div>

  <p>The preceding chapters introduced the basic elements from
  which programs are made. We saw how primitive procedures and
  primitive data are combined to construct compound entities, and
  we learned that abstraction is vital in helping us to cope with
  the complexity of large systems. But these tools are not
  sufficient for designing programs. Effective program synthesis
  also requires organizational principles that can guide us in
  formulating the overall design of a program. In particular, we
  need strategies to help us structure large systems so that they
  will be <em>modular</em>, that is, so that they can be divided
  ``naturally'' into coherent parts that can be separately
  developed and maintained.</p>

  <p><a name="%_idx_2824"></a><a name="%_idx_2826"></a>One powerful
  design strategy, which is particularly appropriate to the
  construction of programs for modeling physical systems, is to
  base the structure of our programs on the structure of the system
  being modeled. For each object in the system, we construct a
  corresponding computational object. For each system action, we
  define a symbolic operation in our computational model. Our hope
  in using this strategy is that extending the model to accommodate
  new objects or new actions will require no strategic changes to
  the program, only the addition of the new symbolic analogs of
  those objects or actions. If we have been successful in our
  system organization, then to add a new feature or debug an old
  one we will have to work on only a localized part of the
  system.</p>

  <p>To a large extent, then, the way we organize a large program
  is dictated by our perception of the system to be modeled. In
  this chapter we will investigate two prominent organizational
  strategies arising from two rather different ``world views'' of
  the structure of systems. The first organizational strategy
  concentrates on <a name="%_idx_2828"></a><em>objects</em>,
  viewing a large system as a collection of distinct objects whose
  behaviors may change over time. An alternative organizational
  strategy concentrates on the <a name="%_idx_2830"></a><em>streams</em> of information that flow in the
  system, much as an electrical engineer views a signal-processing
  system.</p>

  <p>Both the object-based approach and the stream-processing
  approach raise significant linguistic issues in programming. With
  objects, we must be concerned with how a computational object can
  change and yet maintain its identity. This will force us to
  abandon our old substitution model of computation
  (section&nbsp;<a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a>)
  in favor of a more mechanistic but less theoretically tractable
  <a name="%_idx_2832"></a><em>environment model</em> of
  computation. The difficulties of dealing with objects, change,
  and identity are a fundamental consequence of the need to grapple
  with time in our computational models. These difficulties become
  even greater when we allow the possibility of concurrent
  execution of programs. The stream approach can be most fully
  exploited when we decouple simulated time in our model from the
  order of the events that take place in the computer during
  evaluation. We will accomplish this using a technique known as
  <a name="%_idx_2834"></a><em>delayed evaluation</em>.</p>

  
</body>
</html>
